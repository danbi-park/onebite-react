# TIL - useRef


# useRef vs useState

## useRef
- Reference 객체를 생성
- 컴포넌트 내부의 변수로 활용 가능
- 어떤 경우에도 리렌더링을 유발하지 않음


## useState
- State를 생성
- 컴포넌트 내부의 변수로 활용 가능
- 값이 변경되면 컴포넌트 리렌더링


컴포넌트가 렌더링하는 DOM에 접근이 가능하고 요소 조작이 가능하다.



```jsx
const refObj = useRef(); //current : undefined
const refObj = useRef(0); //current : 0 
```

current에 값을 지정할 수 있다. 
```jsx
    const countRef = useRef(0); // 초기값 지정

    const onChange = (e) => {
        countRef.current++; // 초기값 더하기
        console.log(countRef.current);

        setInput({
            ...input,
            [e.target.name]: e.target.value
        })
    }
```


```jsx
const inputRef = useRef(); //1. inputRef 생성

//2. ref 속성에 추가
 <input type="text"
    name="name"
    ref={inputRef}
    value={input.name}
    placeholder="이름"
    onChange={onChange}
/>

// console.log로 출력 시 다음과 같이 나옴
// console.log(inputRef.current);
<input placeholder="이름" type="text" value name="name">
```


## 왜 useRef를 사용해야 할까?

### 문제 상황: 일반 변수의 한계
```jsx
function Register() {
    let count = 0; // 컴포넌트 렌더링 시마다 초기화
    
    const onChange = (e) => {
        count++; // 증가시키지만
        console.log(count); // 항상 1만 출력됨
        
        setInput({
            ...input,
            [e.target.name]: e.target.value
        });
    };
}
```

**문제점**: `onChange`가 실행되어 `input` 값이 변경되면 컴포넌트가 리렌더링됨. 리렌더링 시 `let count = 0`이 다시 실행되어 `count`가 항상 0으로 초기화되기 때문에, 증가시켜도 계속 1만 출력.

### 잘못된 해결책: 외부 변수 사용
```jsx
let count = 0; // 컴포넌트 외부에 선언

function Register() {
    const onChange = (e) => {
        count++; // 이제 증가는!! 됨
        console.log(count); // 누적된 값 출력
        
        setInput({
            ...input,
            [e.target.name]: e.target.value
        });
    };
}
```

**문제점**: 
- `Register` 컴포넌트를 여러 곳에서 사용할 경우, 모든 인스턴스가 같은 `count` 변수를 공유하게 됨
- 컴포넌트의 독립성이 보장되지 않아 예상치 못한 버그가 발생할 수 있음

### 올바른 해결책: useRef 사용
```jsx
function Register() {
    const countRef = useRef(0); // 각 컴포넌트 인스턴스마다 독립적인 값
    
    const onChange = (e) => {
        countRef.current++; // 값이 증가하고
        console.log(countRef.current); // 이전 값이 유지되어 누적됨
        
        setInput({
            ...input,
            [e.target.name]: e.target.value
        });
    };
}
```

**장점**:
- 각 컴포넌트 인스턴스마다 독립적인 값을 가짐
- 리렌더링과 무관하게 값이 유지
- 컴포넌트의 캡슐화 보장